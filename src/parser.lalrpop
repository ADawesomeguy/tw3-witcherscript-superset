use std::str::FromStr;
use crate::ast::{
    Program,
    Expression,
    OperationCode,
    TypedIdentifier,
    Statement,
    FunctionDeclaration,
    TypeDeclaration,
    VariableDeclaration,
    FunctionBodyStatement,
    FunctionCallParameters,
    IdentifierTerm,
    AssignmentType,
    IfStatement,
    ComparisonType,
    ForStatement,
    VariableDeclarationOrAssignment,
    VariableAssignment,
    WhileStatement,
    DoWhileStatement,
    ClassDeclaration,
    ClassBodyStatement,
    ClassType,
    EncapsulationType
};

grammar;

pub Program: Program = {
    <statements:(<Statement>)*> => Program { statements }
}

Statement: Statement = {
    // Expression => Statement::Expression(<>),
    FunctionDeclaration => Statement::FunctionDeclaration(<>),
    ClassDeclaration => Statement::ClassDeclaration(<>)
};

// -----------------------------------------------------------------------------

ClassDeclaration: ClassDeclaration = {
    <statemachine:KeywordStatemachine?> KeywordClass <name: Identifier> <extended_class_name:(KeywordExtends <Identifier>)?>
    "{" <body_statements:(<ClassBodyStatement>)*> "}"
        => ClassDeclaration {
            class_type: match statemachine.is_some() {
                true => ClassType::StatemachineClass,
                false => ClassType::Class
            },
            name,
            extended_class_name,
            body_statements
        }
}

ClassBodyStatement: ClassBodyStatement = {
    <encapsulation:EncapsulationType?> <property_declaration:VariableDeclaration> ";" => ClassBodyStatement::Property {
        encapsulation,
        property_declaration
    },

    <encapsulation:EncapsulationType?> <function_declaration:FunctionDeclaration> => ClassBodyStatement::Method {
        encapsulation,
        function_declaration
    },

    KeywordDefault <VariableAssignment> ";" => ClassBodyStatement::DefaultValue(<>)
}

EncapsulationType: EncapsulationType = {
    KeywordPublic => EncapsulationType::Public,
    KeywordPrivate => EncapsulationType::Private,
    KeywordProtected => EncapsulationType::Protected
}

// -----------------------------------------------------------------------------

FunctionDeclaration: FunctionDeclaration = {
    <latent:KeywordLatent?> KeywordFunction <name: Identifier> "(" <parameters:SeparatedTypedIdentifier> ")" <type_declaration:TypeDeclaration?>
    "{" <body_statements:(<FunctionBodyStatement>)*> "}"
        => FunctionDeclaration::Function {
            name,
            parameters,
            type_declaration: type_declaration,
            body_statements,
            is_latent: latent.is_some()
        }
};

FunctionBodyStatement: FunctionBodyStatement = {
    <var:VariableDeclaration> ";" => FunctionBodyStatement::VariableDeclaration(var),
    <expression:Expression> ";" => FunctionBodyStatement::Expression(expression),
    
    KeywordReturn <expression:Expression> ";" => FunctionBodyStatement::Return(expression),

    <var:VariableAssignment> ";" => FunctionBodyStatement::Assignement(<>),
    IfStatement => FunctionBodyStatement::IfStatement(<>),
    ForStatement => FunctionBodyStatement::ForStatement(<>),
    WhileStatement => FunctionBodyStatement::WhileStatement(<>),
    <DoWhileStatement> ";" => FunctionBodyStatement::DoWhileStatement(<>)
}

// -----------------------------------------------------------------------------

VariableAssignment: VariableAssignment = {
    <variable_name:IdentifierTerm> <assignment_type:AssignmentType> <following_expression:Expression>
        => VariableAssignment {
            variable_name,
            assignment_type,
            following_expression
        }
}

// -----------------------------------------------------------------------------

IfStatement: IfStatement = {
    KeywordIf "(" <condition:Expression> ")" "{" <body_statements:(<FunctionBodyStatement>)*> "}" <else_statements:(<ElseStatement>)*>
        => IfStatement::If {
            condition,
            body_statements,
            else_statements
        }
}

ElseStatement: Box<IfStatement> = {
    KeywordElse <condition:(KeywordIf "(" <Expression> ")")?> "{" <body_statements:(<FunctionBodyStatement>)*> "}"
        => Box::new(IfStatement::Else {
            condition,
            body_statements
        })
}

// -----------------------------------------------------------------------------

ForStatement: ForStatement = {
    KeywordFor "(" <initialization:VariableDeclarationOrAssignment?> ";" <condition:Expression> ";" <iteration:VariableAssignment>  ")"
    "{" <body_statements:(<FunctionBodyStatement>)*> "}"
        => ForStatement { initialization, condition, iteration, body_statements }
}

VariableDeclarationOrAssignment: VariableDeclarationOrAssignment = {
    VariableDeclaration => VariableDeclarationOrAssignment::Declaration(<>),
    VariableAssignment => VariableDeclarationOrAssignment::Assignement(<>)
}

// -----------------------------------------------------------------------------

WhileStatement: WhileStatement = {
    KeywordWhile "(" <condition:Expression> ")" "{" <body_statements:(<FunctionBodyStatement>)*> "}"
        => WhileStatement { condition, body_statements }
}

DoWhileStatement: DoWhileStatement = {
    KeywordDo "{" <body_statements:(<FunctionBodyStatement>)*> "}" KeywordWhile "(" <condition:Expression> ")"
        => DoWhileStatement { condition, body_statements }
}

// -----------------------------------------------------------------------------

VariableDeclaration: VariableDeclaration = {
    KeywordVar <typed_identifier: TypedIdentifier> <expression:("=" <Expression>)?> => VariableDeclaration {
        declaration: typed_identifier,
        following_expression: expression
    }
}

// -----------------------------------------------------------------------------

TypedIdentifier: TypedIdentifier = {
    <name:Identifier> <type_declaration:TypeDeclaration> => TypedIdentifier {
        name: name,
        type_name: type_declaration.type_name
    }
}

TypeDeclaration: TypeDeclaration = {
    ":" <type_name:Identifier> => TypeDeclaration { type_name: type_name }
}

// -----------------------------------------------------------------------------

FunctionCallParameters: FunctionCallParameters = {
    "(" <parameters:SeparatedExpressions> ")" => FunctionCallParameters(parameters)
}

// -----------------------------------------------------------------------------

Expression: Box<Expression> = {
    Expression ExprOperation Factor => Box::new(Expression::Operation(<>)),
    Factor,
};

ExprOperation: OperationCode = {
    "+" => OperationCode::Add,
    "-" => OperationCode::Sub,
    ComparisonType => OperationCode::Comparison(<>)
};

Factor: Box<Expression> = {
    Factor FactorOp Term => Box::new(Expression::Operation(<>)),
    Term,
};

FactorOp: OperationCode = {
    "*" => OperationCode::Mul,
    "/" => OperationCode::Div,
};

AssignmentType: AssignmentType = {
    "=" => AssignmentType::Equal,
    "+=" => AssignmentType::PlusEqual,
    "-=" => AssignmentType::MinusEqual,
    "*=" => AssignmentType::AsteriskEqual,
    "/=" => AssignmentType::SlashEqual
}

ComparisonType: ComparisonType = {
    "==" => ComparisonType::Equal,
    "!=" => ComparisonType::Different,
    ">" => ComparisonType::Greater,
    ">=" => ComparisonType::GreaterEqual,
    "<" => ComparisonType::Lower,
    "<=" => ComparisonType::LowerEqual
}

Term: Box<Expression> = {
    Num => Box::new(Expression::Number(<>)),
    "(" <Expression> ")",
    StringLiteral => Box::new(Expression::String(String::from(<>))),

    IdentifierTerm => Box::new(Expression::Identifier(<>)),
    <accessor:IdentifierTerm> <parameters:FunctionCallParameters> => Box::new(Expression::FunctionCall{
        accessor,
        parameters
    }),
};

IdentifierTerm: IdentifierTerm = {
    <ids:DotSeparatedIdentifiers> => IdentifierTerm::NestedIdentifiers(ids),
    <id:Identifier> => IdentifierTerm::Identifier(id)
}

// -----------------------------------------------------------------------------

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Boolean: bool = {
    "true" => true,
    "false" => false
}

Identifier: String = {
    IdentifierRegex => String::from(<>)
}

// -----------------------------------------------------------------------------

SeparatedExpressions = TrailingComma<Expression>;
SeparatedTypedIdentifier = TrailingComma<TypedIdentifier>;

DotSeparatedIdentifiers = DotSeparated<Identifier>;

/// A comma separated list of `T` with the possibility of a trailing comma
TrailingComma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

/// A dot separated list of `T` with NO possibility of a trailing dot
DotSeparated<T>: Vec<T> = {
    <e:T> "." <ee:T> <mut v:("." <T> )*> => {
        v.push(e);
        v.push(ee);
        v
    }
};

/// A Tier,
/// 
///
Tier<Op,NextTier>: Box<Expression> = {
    Tier<Op,NextTier> Op NextTier => Box::new(Expression::Operation(<>)),
    NextTier
};

// `match`: Declares the precedence of regular expressions
// relative to one another when synthesizing
// the lexer
match {
    // These items have highest precedence.
    r"[0-9]+",

    "function" => KeywordFunction,
    "var" => KeywordVar,
    "return" => KeywordReturn,
    "if" => KeywordIf,
    "else" => KeywordElse,
    "for" => KeywordFor,
    "while" => KeywordWhile,
    "do" => KeywordDo,
    "class" => KeywordClass,
    "statemachine" => KeywordStatemachine,
    "extends" => KeywordExtends,
    "private" => KeywordPrivate,
    "public" => KeywordPublic,
    "protected" => KeywordProtected,
    "default" => KeywordDefault,
    "latent" => KeywordLatent
} else {
    // These items have next highest precedence.

    // Given an input like `123`, the number regex above
    // will match; but otherwise, given something like
    // `123foo` or `foo123`, this will match.
    //
    // Here, we also renamed the regex to the name `ID`, which we can
    // use in the grammar itself.
    r"\w+" => IdentifierRegex,

    r#"".*""# => StringLiteral,

    // This `_` means "add in all the other strings and
    // regular expressions in the grammer here" (e.g.,
    // `"("`).
    _
} // you can have more `else` sections if you like